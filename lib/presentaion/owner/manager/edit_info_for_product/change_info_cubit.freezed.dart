// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'change_info_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ChangeInfoState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChangeInfoStateCopyWith<T, $Res> {
  factory $ChangeInfoStateCopyWith(
          ChangeInfoState<T> value, $Res Function(ChangeInfoState<T>) then) =
      _$ChangeInfoStateCopyWithImpl<T, $Res, ChangeInfoState<T>>;
}

/// @nodoc
class _$ChangeInfoStateCopyWithImpl<T, $Res, $Val extends ChangeInfoState<T>>
    implements $ChangeInfoStateCopyWith<T, $Res> {
  _$ChangeInfoStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<T, $Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl<T> value, $Res Function(_$InitImpl<T>) then) =
      __$$InitImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<T, $Res>
    extends _$ChangeInfoStateCopyWithImpl<T, $Res, _$InitImpl<T>>
    implements _$$InitImplCopyWith<T, $Res> {
  __$$InitImplCopyWithImpl(
      _$InitImpl<T> _value, $Res Function(_$InitImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl<T> implements Init<T> {
  const _$InitImpl();

  @override
  String toString() {
    return 'ChangeInfoState<$T>.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class Init<T> implements ChangeInfoState<T> {
  const factory Init() = _$InitImpl<T>;
}

/// @nodoc
abstract class _$$ChangeNameImplCopyWith<T, $Res> {
  factory _$$ChangeNameImplCopyWith(
          _$ChangeNameImpl<T> value, $Res Function(_$ChangeNameImpl<T>) then) =
      __$$ChangeNameImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ChangeNameImplCopyWithImpl<T, $Res>
    extends _$ChangeInfoStateCopyWithImpl<T, $Res, _$ChangeNameImpl<T>>
    implements _$$ChangeNameImplCopyWith<T, $Res> {
  __$$ChangeNameImplCopyWithImpl(
      _$ChangeNameImpl<T> _value, $Res Function(_$ChangeNameImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangeNameImpl<T> implements ChangeName<T> {
  const _$ChangeNameImpl();

  @override
  String toString() {
    return 'ChangeInfoState<$T>.changeName()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChangeNameImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) {
    return changeName();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) {
    return changeName?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) {
    if (changeName != null) {
      return changeName();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) {
    return changeName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) {
    return changeName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) {
    if (changeName != null) {
      return changeName(this);
    }
    return orElse();
  }
}

abstract class ChangeName<T> implements ChangeInfoState<T> {
  const factory ChangeName() = _$ChangeNameImpl<T>;
}

/// @nodoc
abstract class _$$ChangeCaptionImplCopyWith<T, $Res> {
  factory _$$ChangeCaptionImplCopyWith(_$ChangeCaptionImpl<T> value,
          $Res Function(_$ChangeCaptionImpl<T>) then) =
      __$$ChangeCaptionImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ChangeCaptionImplCopyWithImpl<T, $Res>
    extends _$ChangeInfoStateCopyWithImpl<T, $Res, _$ChangeCaptionImpl<T>>
    implements _$$ChangeCaptionImplCopyWith<T, $Res> {
  __$$ChangeCaptionImplCopyWithImpl(_$ChangeCaptionImpl<T> _value,
      $Res Function(_$ChangeCaptionImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangeCaptionImpl<T> implements ChangeCaption<T> {
  const _$ChangeCaptionImpl();

  @override
  String toString() {
    return 'ChangeInfoState<$T>.changeCaption()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChangeCaptionImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) {
    return changeCaption();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) {
    return changeCaption?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) {
    if (changeCaption != null) {
      return changeCaption();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) {
    return changeCaption(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) {
    return changeCaption?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) {
    if (changeCaption != null) {
      return changeCaption(this);
    }
    return orElse();
  }
}

abstract class ChangeCaption<T> implements ChangeInfoState<T> {
  const factory ChangeCaption() = _$ChangeCaptionImpl<T>;
}

/// @nodoc
abstract class _$$ChangeDateImplCopyWith<T, $Res> {
  factory _$$ChangeDateImplCopyWith(
          _$ChangeDateImpl<T> value, $Res Function(_$ChangeDateImpl<T>) then) =
      __$$ChangeDateImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ChangeDateImplCopyWithImpl<T, $Res>
    extends _$ChangeInfoStateCopyWithImpl<T, $Res, _$ChangeDateImpl<T>>
    implements _$$ChangeDateImplCopyWith<T, $Res> {
  __$$ChangeDateImplCopyWithImpl(
      _$ChangeDateImpl<T> _value, $Res Function(_$ChangeDateImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangeDateImpl<T> implements ChangeDate<T> {
  const _$ChangeDateImpl();

  @override
  String toString() {
    return 'ChangeInfoState<$T>.changeDate()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChangeDateImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) {
    return changeDate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) {
    return changeDate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) {
    if (changeDate != null) {
      return changeDate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) {
    return changeDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) {
    return changeDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) {
    if (changeDate != null) {
      return changeDate(this);
    }
    return orElse();
  }
}

abstract class ChangeDate<T> implements ChangeInfoState<T> {
  const factory ChangeDate() = _$ChangeDateImpl<T>;
}

/// @nodoc
abstract class _$$ChangePriceImplCopyWith<T, $Res> {
  factory _$$ChangePriceImplCopyWith(_$ChangePriceImpl<T> value,
          $Res Function(_$ChangePriceImpl<T>) then) =
      __$$ChangePriceImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ChangePriceImplCopyWithImpl<T, $Res>
    extends _$ChangeInfoStateCopyWithImpl<T, $Res, _$ChangePriceImpl<T>>
    implements _$$ChangePriceImplCopyWith<T, $Res> {
  __$$ChangePriceImplCopyWithImpl(
      _$ChangePriceImpl<T> _value, $Res Function(_$ChangePriceImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChangePriceImpl<T> implements ChangePrice<T> {
  const _$ChangePriceImpl();

  @override
  String toString() {
    return 'ChangeInfoState<$T>.changePrice()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChangePriceImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() changeName,
    required TResult Function() changeCaption,
    required TResult Function() changeDate,
    required TResult Function() changePrice,
  }) {
    return changePrice();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? changeName,
    TResult? Function()? changeCaption,
    TResult? Function()? changeDate,
    TResult? Function()? changePrice,
  }) {
    return changePrice?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? changeName,
    TResult Function()? changeCaption,
    TResult Function()? changeDate,
    TResult Function()? changePrice,
    required TResult orElse(),
  }) {
    if (changePrice != null) {
      return changePrice();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init<T> value) init,
    required TResult Function(ChangeName<T> value) changeName,
    required TResult Function(ChangeCaption<T> value) changeCaption,
    required TResult Function(ChangeDate<T> value) changeDate,
    required TResult Function(ChangePrice<T> value) changePrice,
  }) {
    return changePrice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init<T> value)? init,
    TResult? Function(ChangeName<T> value)? changeName,
    TResult? Function(ChangeCaption<T> value)? changeCaption,
    TResult? Function(ChangeDate<T> value)? changeDate,
    TResult? Function(ChangePrice<T> value)? changePrice,
  }) {
    return changePrice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init<T> value)? init,
    TResult Function(ChangeName<T> value)? changeName,
    TResult Function(ChangeCaption<T> value)? changeCaption,
    TResult Function(ChangeDate<T> value)? changeDate,
    TResult Function(ChangePrice<T> value)? changePrice,
    required TResult orElse(),
  }) {
    if (changePrice != null) {
      return changePrice(this);
    }
    return orElse();
  }
}

abstract class ChangePrice<T> implements ChangeInfoState<T> {
  const factory ChangePrice() = _$ChangePriceImpl<T>;
}
